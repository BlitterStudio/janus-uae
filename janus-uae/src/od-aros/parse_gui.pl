#!/usr/bin/perl -w
#=====================================================================
#
# script to parse a windows resource file and extract all strings
# defined there.
#
# Copyright 2014       Oliver Brunner - aros<at>oliver-brunner.de
#
# This file is part of Janus-UAE.
#
# Janus-UAE is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Janus-UAE is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Janus-UAE. If not, see <http://www.gnu.org/licenses/>.
#
#=====================================================================
use strict;
use Switch;
require Tree::Simple;

my $debug=1;

if(!defined $ARGV[1]) {
  die "Usage: parse_gui windows.rc out.cpp"
}

my $res_file=$ARGV[0];
my $cpp_file=$ARGV[1];

local *RESFILE;
local *HFILE;
my $line;
my @part;
my $active=0;
my $key;
my $value;
my $back="";

my $tree;

my $idd_name;
my $idd_active;

open(RESFILE,   $res_file ) or die "unable to open $res_file: $!";
open(HFILE  , ">$cpp_file"  ) or die "unable to open $cpp_file: $!";

print HFILE   "/* This file has been autogenerated with parse_gui.pl from $res_file */ \n\n";

sub gen_node($$) {
  my $type=shift;
  my $args=shift;
  my %node;

  my @attr=split(',', $args);
  switch($type) {
    case "RTEXT" {
      $debug && print "  = RTEXT {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[2]."\n";
      $debug && print "      y:      ".$attr[3]."\n";
      $debug && print "      w:      ".$attr[4]."\n";
      $debug && print "      h:      ".$attr[5]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[2];
      $node{'y'}=$attr[3];
      $node{'w'}=$attr[4];
      $node{'x'}=$attr[5];
    }
    else {
      $debug && print "  = default type\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[2];
      $node{'y'}=$attr[3];
      $node{'w'}=$attr[4];
      $node{'x'}=$attr[5];

    }
  }

  return \%node;
}

# return if a is inside b
sub is_inside($$$) {
  my $rtree=shift;
  my $ranode=shift;
  my $rbnode=shift;

  # everything is inside the root node of course
  if($rbnode eq $$rtree->getChild(0)) {
    return 1;
  }

  $debug && print "compare: ".${$ranode}{'x'}." and ".${$rbnode}{'x'}."\n";

  if(${$ranode}{'x'} >= ${$rbnode}{'x'} and
     ${$ranode}{'y'} >= ${$rbnode}{'y'} and
     ${$ranode}{'x'}+${$ranode}{'w'} <= ${$rbnode}{'x'}+${$ranode}{'w'} and
     ${$ranode}{'y'}+${$ranode}{'h'} <= ${$rbnode}{'y'}+${$ranode}{'h'}) {
    return 1;
  }

  return 0;
}

sub insert_node($$) {
  my $rtree=shift;
  my $rnodedata=shift;

  if($$rtree->getChildCount()==0) {
    $$rtree->addChild(Tree::Simple->new($rnodedata));
  }

  print is_inside($rtree, $$rtree->getChild(0)->getNodeValue(), $rnodedata);

}

sub insert_line($$$) {
  my $rtree=shift;
  my $type=shift;
  my $args=shift;
  my $rnodedata=gen_node($type, $args);


  if(defined $$rnodedata{'string'}) {
    $debug && print "defined\n";
  }

  insert_node($rtree, $rnodedata);
}

my %root;
my $rroot;

while(<RESFILE>) {
  $line=$back.$_;
  $back="";
  chomp($line);
  if($line =~ /DIALOGEX/) {
    $idd_active=1;
    $idd_name=(split(' ', $line))[0];
    $debug && print "=== $idd_name ===\n";
    $root{'string'}=$idd_name;
    $root{'x'}=0;
    $root{'y'}=0;
    $root{'w'}=10000;
    $root{'h'}=10000;
    $rroot=\%root;
    $tree = Tree::Simple->new($rroot, Tree::Simple->ROOT);
    print "==> ".${$tree->getChild(0)->getNodeValue()}{'w'};
    print "==> ".${$tree->getChild(0)->getNodeValue()}{'w'};
  }
  else {

    if($idd_active) {
      if($line =~ /^END/) {
        $active=0;
        $idd_active=0;
        # TODO: finish tree!
      }
      else {
        if(!$active and $line =~ /BEGIN/) {
          $active=1;
        }
        else {
          @part=split " ", $line;
          $key=shift @part;
          $value=join " ",@part;
          if(not $value =~ /"/) {
            # multiline 
            $back=$key." ";
          }
          else {
            # now we have a valid line
            $debug && print " == $key -- $value ==\n";
            insert_line(\$tree, $key, $value);
            print HFILE "#define $key $value\n";
          }

        }

      }
    }
  }

}

$tree->traverse(sub {
  my ($tree) = @_;
    print (("\t" x $tree->getDepth()), $tree->getNodeValue(), "\n");
});

close(RESFILE);
close(HFILE);

