#!/usr/bin/perl -w
#=====================================================================
#
# script to parse a windows resource file and extract all strings
# defined there.
#
# Copyright 2014       Oliver Brunner - aros<at>oliver-brunner.de
#
# This file is part of Janus-UAE.
#
# Janus-UAE is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Janus-UAE is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Janus-UAE. If not, see <http://www.gnu.org/licenses/>.
#
#=====================================================================
use strict;
use Switch;
require Tree::Simple;
use Data::TreeDumper;

#=====================================================================
# global
#=====================================================================
my $debug=1;

my %root;
my $rroot;

my $res_file=$ARGV[0];
my $cpp_file=$ARGV[1];

local *RESFILE;
local *HFILE;
my $line;
my @part;
my $active=0;
my $key;
my $value;
my $back="";

my $tree;

my $idd_name;
my $idd_active;

open(RESFILE,   $res_file ) or die "unable to open $res_file: $!";
open(HFILE  , ">$cpp_file"  ) or die "unable to open $cpp_file: $!";

print HFILE   "/* This file has been autogenerated with parse_gui.pl from $res_file */ \n\n";

sub gen_node($$) {
  my $type=shift;
  my $args=shift;
  my %node;

  my @attr=split(',', $args);
  switch($type) {
    case "RTEXT" {
      $debug && print "  = RTEXT {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[2]."\n";
      $debug && print "      y:      ".$attr[3]."\n";
      $debug && print "      w:      ".$attr[4]."\n";
      $debug && print "      h:      ".$attr[5]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[2];
      $node{'y'}=$attr[3];
      $node{'w'}=$attr[4];
      $node{'h'}=$attr[5];
    }
    case "GROUPBOX" {
      $debug && print "  = GROUPBOX {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[2]."\n";
      $debug && print "      y:      ".$attr[3]."\n";
      $debug && print "      w:      ".$attr[4]."\n";
      $debug && print "      h:      ".$attr[5]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[2];
      $node{'y'}=$attr[3];
      $node{'w'}=$attr[4];
      $node{'h'}=$attr[5];
    }
    case "CONTROL" {
      $debug && print "  = $type {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[4]."\n";
      $debug && print "      y:      ".$attr[5]."\n";
      $debug && print "      w:      ".$attr[6]."\n";
      $debug && print "      h:      ".$attr[7]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[4];
      $node{'y'}=$attr[5];
      $node{'w'}=$attr[6];
      $node{'h'}=$attr[7];
    }
    case "PUSHBUTTON" {
      $debug && print "  = $type {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[2]."\n";
      $debug && print "      y:      ".$attr[3]."\n";
      $debug && print "      w:      ".$attr[4]."\n";
      $debug && print "      h:      ".$attr[5]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[2];
      $node{'y'}=$attr[3];
      $node{'w'}=$attr[4];
      $node{'h'}=$attr[5];
    }
    case "COMBOBOX" {
      $debug && print "  = $type {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[1]."\n";
      $debug && print "      y:      ".$attr[2]."\n";
      $debug && print "      w:      ".$attr[3]."\n";
      $debug && print "      h:      ".$attr[4]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[1];
      $node{'y'}=$attr[2];
      $node{'w'}=$attr[3];
      $node{'h'}=$attr[4];
    }
    case "EDITTEXT" {
      $debug && print "  = $type {\n";
      $debug && print "      string: ".$attr[0]."\n";
      $debug && print "      x:      ".$attr[1]."\n";
      $debug && print "      y:      ".$attr[2]."\n";
      $debug && print "      w:      ".$attr[3]."\n";
      $debug && print "      h:      ".$attr[4]."\n";
      $debug && print "    }\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[1];
      $node{'y'}=$attr[2];
      $node{'w'}=$attr[3];
      $node{'h'}=$attr[4];
    }
    else {
      $debug && print "      => default type\n";
      $node{'string'}=$attr[0];
      $node{'x'}=$attr[2];
      $node{'y'}=$attr[3];
      $node{'w'}=$attr[4];
      $node{'h'}=$attr[5];

    }
  }
  return \%node;
}

# return if a is inside b
sub is_inside($$) {
  #my $rtree=shift;
  my $ranode=shift;
  my $rbnode=shift;
  my $d=$debug;

  # everything is inside the root node of course
  #if($rbnode eq $$rtree->getChild(0)) {
    #$debug && print "THIS SHOULD NOT HAPPEN!\n";
    #return 1;
  #}

  $debug=0;
  $debug && print "compare: ".${$ranode}{'x'}." and ".${$rbnode}{'x'}.": ";
  if(${$ranode}{'x'} >= ${$rbnode}{'x'}) {
    $debug && print "ok";
  }
  $debug && print "\n";
  $debug && print "compare: ".${$ranode}{'y'}." and ".${$rbnode}{'y'}.": ";
  if(${$ranode}{'y'} >= ${$rbnode}{'y'}) {
    $debug && print "ok";
  }
  $debug && print "\n";
  $debug && print "compare: ".${$ranode}{'x'}."+".${$ranode}{'w'}.
                  "=".(${$rbnode}{'x'}+${$rbnode}{'w'}).
                  " and ".${$rbnode}{'x'}.
                  "+".${$rbnode}{'w'}.
                  "=".(${$rbnode}{'x'}+${$rbnode}{'w'}).
                  ": ";
  if((${$ranode}{'x'}+${$ranode}{'w'}) <= (${$rbnode}{'x'}+${$rbnode}{'w'})) {
    $debug && print "ok";
  }
  $debug && print "\n";
  $debug && print "compare: ".${$ranode}{'h'}." and ".${$rbnode}{'h'}.": ";
  if(${$ranode}{'y'}+${$ranode}{'h'} <= ${$rbnode}{'y'}+${$rbnode}{'h'}) {
    $debug && print "ok";
  }
  $debug && print "\n";

  $debug=$d;
  if(${$ranode}{'x'} >= ${$rbnode}{'x'} and
     ${$ranode}{'y'} >= ${$rbnode}{'y'} and
     ((${$ranode}{'x'}+${$ranode}{'w'}) <= (${$rbnode}{'x'}+${$rbnode}{'w'})) and
     ((${$ranode}{'y'}+${$ranode}{'h'}) <= (${$rbnode}{'y'}+${$rbnode}{'h'}))
    ) {
    $debug && print "        IS INSIDE!!\n";
    return 1;
  }

  return 0;
}

sub insert_node($$);

sub insert_node($$) {
  my $rtree=shift;
  my $rnodedata=shift;
  my $child;
  my $rdata;

  $rdata=$$rtree->getNodeValue();

  if($$rtree->getChildCount()==0) {
    $debug && print "      first child ".$$rnodedata{'string'}." inserted into ".$$rdata{'string'}."\n";
    # we have no child so far, so we simply add it and are done
    $$rtree->addChild(Tree::Simple->new($rnodedata));
    return;
  }

  foreach $child ($$rtree->getAllChildren()) {
    # now we have to check, if our new node is inside the actual child.
    # if it is, recursivly add the new node to the child 
    #if(is_inside($rtree, $$rtree->getChild(0)->getNodeValue(), $rnodedata)) {
    $debug && print "        check child..\n";
    if(is_inside($rnodedata, $child->getNodeValue())) {
      $debug && print "        call insert_node again..\n";
      insert_node(\$child, $rnodedata);
      return;
    }
  };


  # we are not inside one of the children, so we are a sibling:
  $debug && print "        added ".$$rnodedata{'string'}." as another new child to ".$$rdata{'string'}."\n";
  $$rtree->addChild(Tree::Simple->new($rnodedata));
}

sub insert_line($$$) {
  my $rtree=shift;
  my $type=shift;
  my $args=shift;
  my $rnodedata=gen_node($type, $args);


  if(defined $$rnodedata{'string'}) {
    $debug && print "      defined string: ".$$rnodedata{'string'}."\n";
  }

  insert_node($rtree, $rnodedata);
}

#===================================================================0
# getx(string 1,0,393,163)
#===================================================================0
sub getx($) {
  my $string=shift;
  return (split ',',$string)[0];
}
#===================================================================0
# gety(string 1,0,393,163)
#===================================================================0
#===================================================================0
# getw(string 1,0,393,163)
#===================================================================0
#===================================================================0
# geth(string 1,0,393,163)
#===================================================================0

#===================================================================0
# main
#===================================================================0
if(!defined $ARGV[1]) {
  die "Usage: parse_gui windows.rc out.cpp"
}

while(<RESFILE>) {
  $line=$back.$_;
  $back="";
  chomp($line);
  #$debug && print ("************************************************************************\n");
  #$debug && print ("ACTUAL LINE: $line\n");
  #$debug && print ("************************************************************************\n");
  if($line =~ /^;/) {
  }
  elsif($line =~ /DIALOGEX/) {
    # IDD_FLOPPY DIALOGEX 0, 0, 396, 261
    my @t;
    $line=~s/\,//g; # remove all ,
    @t=split(' ', $line);
    $idd_name=$t[0];
    $debug && print "=== $idd_name ===\n";
    $idd_active=1;
    # shift away "IDD_FLOPPY DIALOGEX"
    shift(@t);
    shift(@t);
    $root{'x'}=$t[0];
    $root{'y'}=$t[1];
    $root{'w'}=$t[2];
    $root{'h'}=$t[3];
    $root{'string'}=$idd_name;
    $debug && print "    x ".$root{'x'}." y ".$root{'y'}." w ".$root{'w'}." h ".$root{'h'}."\n";
    $rroot=\%root;
    $tree = Tree::Simple->new($rroot, Tree::Simple->ROOT);
    # now we have a tree with a root node
  }
  else {
    if($idd_active) {
      #we are in a DIALOGEX object, but not in the list of childs
      if($line =~ /^END/) {
        $active=0;
        $idd_active=0;
        $debug && print ("=== END OF $idd_name ==\n");
        # TODO: finish tree!
      }
      else {
        if(!$active and $line =~ /BEGIN/) {
          # list of childs start after BEGIN
          $debug && print "          .. active\n";
          $active=1;
        }
        elsif($active) {
          # GROUPBOX        "Floppy Drives",IDC_SETTINGSTEXT3,1,0,393,163
          # COMBOBOX        IDC_DF1TYPE,152,51,65,50,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
          # RTEXT           "Write-protected",IDC_STATIC,221,53,74,10,SS_CENTERIMAGE
          # ...
          @part=split " ", $line;
          $key=shift @part;
          $debug && print " == $key ==\n";
          $value=join " ",@part;
          # care for multilines?
          ##if(not $value =~ /"/) {
            # multiline 
            ##$back=$key." ";
          ##}
          ##else {
            # now we have a valid line
            $debug && print "      $value\n";
            insert_line(\$tree, $key, $value);
            print HFILE "#define $key $value\n";
          ##}

        }

      }
    }
  }

}


#$tree->traverse(sub {
  #my ($tree) = @_;
    #print (("\t" x $tree->getDepth()), $tree->getNodeValue(), "\n");
#});
print DumpTree($tree, 'title');

close(RESFILE);
close(HFILE);

